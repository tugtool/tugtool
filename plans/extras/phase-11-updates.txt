diff --git a/plans/phase-11.md b/plans/phase-11.md
index d6a1584..1cc3341 100644
--- a/plans/phase-11.md
+++ b/plans/phase-11.md
@@ -501,38 +501,84 @@ pub enum ImportKind {
     /// Re-export (e.g., Rust `pub use`, TypeScript `export { ... } from`)
     ReExport,
     /// Default import (JavaScript/TypeScript)
     Default,
 }
 
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
 #[serde(rename_all = "snake_case")]
 #[derive(Default)]
 pub enum ModuleKind {
-    /// Single-file module.
+    /// Single-file module (e.g., `foo.rs`, `foo.py`).
     #[default]
     File,
     /// Directory-based module/package (Rust mod.rs, Go package, Python package).
     Directory,
+    /// Inline module defined within another file (Rust `mod foo { ... }`).
+    Inline,
     /// Namespace module (no concrete file, language-defined).
     Namespace,
 }
 ```
 
+**Import Builder Pattern:**
+
+```rust
+impl Import {
+    /// Create a new import. Defaults to `ImportKind::Module` (bare `import foo`).
+    pub fn new(module_path: &str) -> Self {
+        Self { kind: ImportKind::Module, module_path: module_path.to_string(), ... }
+    }
+
+    /// Set imported name. Auto-sets kind to `Named`.
+    pub fn with_imported_name(mut self, name: &str) -> Self {
+        self.imported_name = Some(name.to_string());
+        self.kind = ImportKind::Named;
+        self
+    }
+
+    /// Set alias. Auto-sets kind to `Alias`.
+    pub fn with_alias(mut self, alias: &str) -> Self {
+        self.alias = Some(alias.to_string());
+        self.kind = ImportKind::Alias;
+        self
+    }
+
+    /// Set glob import. Sets kind to `Glob`.
+    pub fn with_glob(mut self) -> Self {
+        self.kind = ImportKind::Glob;
+        self
+    }
+
+    /// Explicit kind override (for ReExport, Default, etc.).
+    pub fn with_kind(mut self, kind: ImportKind) -> Self {
+        self.kind = kind;
+        self
+    }
+}
+```
+
 **Rationale:**
 - `Import.is_star` is too narrow; different languages need richer import/re-export semantics.
 - `ModuleKind::Package` is Python-biased; `Directory` is language-agnostic.
+- `ModuleKind::Inline` needed for Rust `mod foo { ... }` blocks within a file.
 - Explicit `ImportKind` supports future refactors (move-module, re-export rewrites).
+- Builder pattern auto-sets `ImportKind` from context, reducing errors.
 
 **Implications:**
 - Replace `Import.is_star` with `Import.kind: ImportKind`
-- Update Python analyzer to populate `ImportKind` (Module/Named/Alias/Glob)
+- `Import::new()` defaults to `ImportKind::Module` (bare import)
+- `with_imported_name()` auto-sets `ImportKind::Named`
+- `with_alias()` auto-sets `ImportKind::Alias`
+- `with_glob()` replaces `with_star()` and sets `ImportKind::Glob`
+- Remove `with_star()` method entirely
+- Update Python analyzer to use new builder pattern
 - Update module docs to avoid `__init__.py`-specific language
 - Update any logic assuming `ModuleKind::Package`
 
 #### [D05] ScopeKind Extension Strategy (DECIDED) {#d05-scope-kind-extension}
 
 **Decision:** Add Rust-specific `ScopeKind` variants without removing Python ones. Consider adding `#[non_exhaustive]` for future-proofing.
 
 Current Python-oriented variants:
 ```rust
 pub enum ScopeKind {
@@ -588,35 +634,41 @@ This matches the current Python analyzer design where multi-file resolution happ
 
 ```rust
 /// Trait for language-specific analysis adapters.
 ///
 /// Each supported language implements this trait to provide:
 /// - Single-file analysis (scopes, symbols, references)
 /// - Multi-file analysis with cross-file resolution
 /// - Symbol lookup at positions
 /// - Export collection
 ///
-/// **ID Ownership:** Adapters do NOT allocate SymbolId, ScopeId, etc.
-/// They use local indices for internal references. The integration layer
-/// (CLI or caller) allocates IDs when converting adapter data to FactsStore.
+/// **ID Ownership:** Adapters do NOT allocate any IDs (FileId, SymbolId, etc.).
+/// All cross-references within adapter data use indices:
+/// - `scope_index`: Index into `FileAnalysisResult.scopes`
+/// - `symbol_index`: Index into `FileAnalysisResult.symbols`
+/// - `file_index`: Index into `AnalysisBundle.file_results`
+///
+/// The integration layer allocates IDs and converts adapter data to FactsStore types.
 ///
 /// **FactsStore Usage:** The `store` parameter is read-only context.
 /// For Phase 11, it is typically empty. Adapters must not assume it
 /// contains prior data.
 pub trait LanguageAdapter {
     /// The error type for this adapter.
     type Error: std::error::Error;
 
     /// Analyze a single file and return local analysis results.
+    ///
+    /// **No FileId parameter:** Adapters do not need or allocate IDs.
+    /// The integration layer assigns FileId after receiving results.
     fn analyze_file(
         &self,
-        file_id: FileId,
         path: &str,
         content: &str,
     ) -> Result<FileAnalysisResult, Self::Error>;
 
     /// Analyze multiple files with cross-file resolution.
     ///
     /// The `store` is read-only context. For Phase 11, assume it is empty
     /// and build all cross-file state internally.
     fn analyze_files(
         &self,
@@ -833,20 +885,99 @@ These versions are **independent** with different cadences and consumers. Update
 - Keeps versioning centralized at the root of the serialized facts
 - Avoids duplicating version fields in nested structs
 - Separating internal and output schema versions allows independent evolution
 
 **Implications:**
 - All JSON output that includes serialized FactsStore must include `schema_version`
 - Golden tests should assert the version value
 - Set `FACTS_SCHEMA_VERSION = 11` for this phase; increment on future breaking schema changes
 - `SCHEMA_VERSION` in `output.rs` is not modified in this phase
 
+#### [D12] Re-export Modeling Rule (DECIDED) {#d12-reexport-rule}
+
+**Decision:** A re-export creates **both** an `Import` and a `PublicExport` record.
+
+```rust
+// For Rust `pub use foo::Bar;`:
+Import {
+    kind: ImportKind::ReExport,
+    module_path: "foo",
+    imported_name: Some("Bar"),
+    ...
+}
+PublicExport {
+    export_origin: ExportOrigin::ReExport,
+    exported_name: Some("Bar"),
+    origin_module_id: Some(foo_module_id),
+    ...
+}
+
+// For TypeScript `export { foo } from './bar';`:
+Import { kind: ImportKind::ReExport, ... }
+PublicExport { export_origin: ExportOrigin::ReExport, ... }
+```
+
+**Why both records:**
+- The `Import` answers "what does this module depend on?" (provenance)
+- The `PublicExport` answers "what does this module expose?" (visibility)
+- Move-module refactors need both: update the import path AND update consumers of the export
+
+**Language-specific notes:**
+| Language | Re-export Syntax | Records Created |
+|----------|-----------------|-----------------|
+| **Rust** | `pub use foo::Bar;` | `Import(ReExport)` + `PublicExport(ReExport)` |
+| **TypeScript** | `export { foo } from './bar';` | `Import(ReExport)` + `PublicExport(ReExport)` |
+| **Python** | (no re-export syntax) | If name in `__all__` is imported: `Import(Named)` + `PublicExport(Local)` |
+
+For Python, `origin_module_id` on `PublicExport` can point to where the symbol was originally defined to track re-export chains.
+
+**Rationale:**
+- Consistent representation across languages
+- Supports move-module and re-export rewrite refactors
+- Avoids duplicating logic to compute dependencies vs exports
+
+**Implications:**
+- Rust analyzer will create both records for `pub use`
+- TypeScript analyzer will create both records for `export from`
+- Python `__all__` with imported names creates `PublicExport(Local)` not `ReExport`
+
+#### [D13] Python Effective Exports Deferred (DECIDED) {#d13-python-effective-exports}
+
+**Decision:** For Phase 11, Python only emits `ExportIntent::Declared` for explicit `__all__` entries. `ExportIntent::Effective` computation is deferred to a future phase.
+
+**Rationale:**
+Python's "effective public API" when `__all__` is absent requires a second pass after all symbols are collected. It's orthogonal to the schema work and adds implementation complexity.
+
+**Deferred effective export rule (documented for future implementation):**
+```
+If __all__ exists:
+  effective_exports = declared_exports = __all__ entries
+
+If __all__ absent:
+  effective_exports = {
+    module-level symbols where:
+      - name doesn't start with "_", OR
+      - name is "__dunder__"
+    AND
+      - symbol is defined in this file (not imported)
+  }
+```
+
+**Phase 11 behavior:**
+- Python analyzer emits `ExportIntent::Declared` for `__all__` entries only
+- `ExportIntent::Effective` is reserved for languages like Go where public/private is implicit (uppercase)
+- No effective export computation for Python in this phase
+
+**Future phase:**
+- Add `PythonAnalyzerOptions.compute_effective_exports: bool`
+- When enabled, emit `ExportIntent::Effective` entries for module-level public symbols
+
 ---
 
 ### 11.0.1 Deep Dive: Visibility Model Mapping {#visibility-mapping}
 
 This section details how visibility maps across languages.
 
 **Table T01: Visibility Mapping Across Languages** {#t01-visibility-mapping}
 
 | Language | Public | Crate | Module | Private | Protected |
 |----------|--------|-------|--------|---------|-----------|
@@ -1087,23 +1218,28 @@ pub enum Visibility {
 }
 
 // ============================================================================
 // ModuleKind (generalized)
 // ============================================================================
 
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
 #[serde(rename_all = "snake_case")]
 #[derive(Default)]
 pub enum ModuleKind {
+    /// Single-file module (e.g., `foo.rs`, `foo.py`).
     #[default]
     File,
+    /// Directory-based module/package (Rust mod.rs, Go package, Python package).
     Directory,
+    /// Inline module defined within another file (Rust `mod foo { ... }`).
+    Inline,
+    /// Namespace module (no concrete file, language-defined).
     Namespace,
 }
 
 // ============================================================================
 // PublicExport
 // ============================================================================
 
 /// Unique identifier for a public export.
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
 pub struct PublicExportId(pub u32);
@@ -1361,30 +1497,45 @@ pub struct SymbolData {
     /// Symbol name
     pub name: String,
     /// Declaration span
     pub decl_span: Span,
     /// Index of containing scope in the file's scope list
     pub scope_index: usize,
     /// Inferred visibility (if applicable)
     pub visibility: Option<Visibility>,
 }
 
+/// Reference kind for adapter output.
+///
+/// Mirrors `facts::ReferenceKind` but defined separately to keep adapters
+/// independent of FactsStore internals. The integration layer maps between them.
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+pub enum ReferenceKind {
+    Read,
+    Write,
+    Call,
+    Import,
+    Attribute,
+    TypeAnnotation,
+    Delete,  // Python del
+}
+
 /// Reference information from single-file analysis.
 pub struct ReferenceData {
     /// Name being referenced
     pub name: String,
     /// Byte span of the reference
     pub span: Span,
     /// Index of containing scope in the file's scope list
     pub scope_index: usize,
-    /// Whether this is a write (assignment target) or read
-    pub is_write: bool,
+    /// Kind of reference (read, write, call, etc.)
+    pub kind: ReferenceKind,
 }
 
 /// Import information from single-file analysis.
 pub struct ImportData {
     /// The module path being imported (e.g., "os.path")
     pub module_path: String,
     /// Imported name (None for `import module`)
     pub imported_name: Option<String>,
     /// Local alias (e.g., `as alias`)
     pub alias: Option<String>,
@@ -1415,36 +1566,47 @@ pub struct ExportData {
     /// Origin classification
     pub export_origin: ExportOrigin,
     /// Origin module path (optional, for re-export chains)
     pub origin_module_path: Option<String>,
 }
 
 /// Type information from analysis.
 ///
 /// Collected at the bundle level rather than per-file because type resolution
 /// may require cross-file context.
+///
+/// **Index Semantics:**
+/// - `file_index`: Index into `AnalysisBundle.file_results` array
+/// - `symbol_index`: Index into `FileAnalysisResult.symbols` for that file
+///
+/// The integration layer uses these indices to resolve actual IDs after
+/// allocating FileId/SymbolId for each entry.
 pub struct TypeInfoData {
-    /// Index of the symbol this type applies to (in the file's symbol list).
-    pub symbol_index: usize,
-    /// Index of the file containing the symbol.
+    /// Index into `AnalysisBundle.file_results` for the file containing this symbol.
     pub file_index: usize,
+    /// Index into that file's `symbols` array for the symbol this type applies to.
+    pub symbol_index: usize,
     /// String representation of the type.
     pub type_repr: String,
     /// Source of type information.
     pub source: TypeSource,
     /// Optional structured type representation.
     pub structured: Option<TypeNode>,
 }
 
 /// Result of single-file analysis.
+///
+/// **No FileId:** Adapters do not allocate IDs. The integration layer assigns
+/// FileId after receiving results. Use the index into `AnalysisBundle.file_results`
+/// as the file identifier within adapter data.
 pub struct FileAnalysisResult {
-    pub file_id: FileId,
+    /// Path to the analyzed file (used for ID allocation and error reporting).
     pub path: String,
     pub scopes: Vec<ScopeData>,
     pub symbols: Vec<SymbolData>,
     pub references: Vec<ReferenceData>,
     pub imports: Vec<ImportData>,
     pub exports: Vec<ExportData>,
 }
 
 /// Bundle of multi-file analysis results.
 pub struct AnalysisBundle {
@@ -1452,30 +1614,45 @@ pub struct AnalysisBundle {
     pub failed_files: Vec<(String, String)>, // (path, error)
     /// Type information collected across all files.
     ///
     /// Stored at bundle level because type resolution may require cross-file
     /// context. The integration layer converts these to `TypeInfo` entries
     /// in `FactsStore`.
     pub types: Vec<TypeInfoData>,
 }
 
 /// Trait for language-specific analyzers.
+///
+/// **ID Ownership:** Adapters do NOT allocate any IDs (FileId, SymbolId, etc.).
+/// All cross-references within adapter data use indices:
+/// - `scope_index`: Index into `FileAnalysisResult.scopes`
+/// - `symbol_index`: Index into `FileAnalysisResult.symbols`
+/// - `file_index`: Index into `AnalysisBundle.file_results`
+///
+/// The integration layer allocates IDs and converts adapter data to FactsStore types.
 pub trait LanguageAdapter {
     type Error: std::error::Error + Send + Sync + 'static;
 
+    /// Analyze a single file and return local analysis results.
+    ///
+    /// **No FileId parameter:** The adapter does not need to know the FileId.
+    /// The integration layer will assign IDs after receiving results.
     fn analyze_file(
         &self,
-        file_id: FileId,
         path: &str,
         content: &str,
     ) -> Result<FileAnalysisResult, Self::Error>;
 
+    /// Analyze multiple files with cross-file resolution.
+    ///
+    /// The `store` is read-only context. For Phase 11, assume it is empty
+    /// and build all cross-file state internally.
     fn analyze_files(
         &self,
         files: &[(String, String)],
         store: &FactsStore,
     ) -> Result<AnalysisBundle, Self::Error>;
 
     fn language(&self) -> Language;
 
     fn can_handle(&self, path: &str) -> bool;
 }
@@ -1517,36 +1694,39 @@ pub trait LanguageAdapter {
 |--------|------|----------|-------|
 | `Visibility` | enum | `facts/mod.rs` | 5 variants: Public, Crate, Module, Private, Protected |
 | `PublicExportId` | struct | `facts/mod.rs` | Newtype for u32 |
 | `PublicExport` | struct | `facts/mod.rs` | Language-agnostic export |
 | `ExportKind` | enum | `facts/mod.rs` | 6 variants: PythonAll, RustPubUse, RustPubUseGlob, RustPubMod, JsExport, GoExported |
 | `ExportTarget` | enum | `facts/mod.rs` | 4 variants: Single, Glob, Module, Implicit |
 | `ExportIntent` | enum | `facts/mod.rs` | Declared vs Effective export entries |
 | `ExportOrigin` | enum | `facts/mod.rs` | Local, ReExport, Implicit, Unknown |
 | `ImportKind` | enum | `facts/mod.rs` | Module, Named, Alias, Glob, ReExport, Default |
 | `ModuleKind::Directory` | variant | `facts/mod.rs` | Generalized directory-based module |
+| `ModuleKind::Inline` | variant | `facts/mod.rs` | Rust inline module (`mod foo { ... }`) |
+| `ModuleKind::Namespace` | variant | `facts/mod.rs` | Virtual module with no concrete file |
 | `TypeNode` | enum | `facts/mod.rs` | Structured types + `Extension` variant |
 | `FACTS_SCHEMA_VERSION` | const | `facts/mod.rs` | `u32 = 11` schema version |
 | `ScopeKind::Impl` | variant | `facts/mod.rs` | Rust impl block |
 | `ScopeKind::Trait` | variant | `facts/mod.rs` | Rust trait definition |
 | `ScopeKind::Closure` | variant | `facts/mod.rs` | Rust closure |
 | `ScopeKind::Unsafe` | variant | `facts/mod.rs` | Rust unsafe block |
 | `ScopeKind::MatchArm` | variant | `facts/mod.rs` | Rust match arm |
 | `Symbol::visibility` | field | `facts/mod.rs` | `Option<Visibility>` |
 | `TypeInfo::structured` | field | `facts/mod.rs` | `Option<TypeNode>` |
 | `LanguageAdapter` | trait | `adapter.rs` | Analyzer interface |
 | `FileAnalysisResult` | struct | `adapter.rs` | Single-file result |
 | `AnalysisBundle` | struct | `adapter.rs` | Multi-file result |
 | `TypeInfoData` | struct | `adapter.rs` | Type info for adapter output |
 | `ScopeData` | struct | `adapter.rs` | Scope info for adapter output |
 | `SymbolData` | struct | `adapter.rs` | Symbol info for adapter output |
 | `ReferenceData` | struct | `adapter.rs` | Reference info for adapter output |
+| `ReferenceKind` (adapter) | enum | `adapter.rs` | Read, Write, Call, Import, Attribute, TypeAnnotation, Delete |
 | `ImportData` | struct | `adapter.rs` | Import info for adapter output |
 | `ExportData` | struct | `adapter.rs` | Export info for adapter output |
 | `PythonAdapter` | struct | `tugtool-python/analyzer.rs` | Implements LanguageAdapter |
 | `PythonAnalyzerOptions` | struct | `tugtool-python/analyzer.rs` | Analysis configuration |
 
 ---
 
 ### 11.3 Documentation Plan {#documentation-plan}
 
 - [ ] Update CLAUDE.md with new types and their purpose (no legacy compatibility notes)
@@ -1559,24 +1739,24 @@ pub trait LanguageAdapter {
 - [ ] Note FactsStore schema changes in internal docs where referenced
 
 ---
 
 ### 11.4 Test Plan Concepts {#test-plan-concepts}
 
 #### Test Categories {#test-categories}
 
 | Category | Purpose | When to use |
 |----------|---------|-------------|
-| **Unit** | Test enum serialization, default values | Visibility, ExportKind, ExportTarget, ExportIntent, ExportOrigin, ImportKind, ModuleKind, TypeNode |
+| **Unit** | Test enum serialization, default values | Visibility, ExportKind, ExportTarget, ExportIntent, ExportOrigin, ImportKind, ModuleKind, TypeNode, ReferenceKind (adapter) |
 | **Golden** | Verify new schema format correctness | JSON output for Symbol, PublicExport (incl. spans), TypeNode, schema_version |
 | **Integration** | Verify Python analyzer works with new types | End-to-end rename using new schema |
-| **Adapter** | Verify LanguageAdapter produces correct output | PythonAdapter results match expectations |
+| **Adapter** | Verify LanguageAdapter produces correct output | PythonAdapter results match expectations, index-based references |
 
 #### Test Fixtures {#test-fixtures}
 
 **Visibility Serialization:**
 ```rust
 #[test]
 fn visibility_serialization() {
     assert_eq!(serde_json::to_string(&Visibility::Public).unwrap(), "\"public\"");
     assert_eq!(serde_json::to_string(&Visibility::Crate).unwrap(), "\"crate\"");
 }
@@ -1669,20 +1849,43 @@ fn export_origin_serialization() {
 ```rust
 #[test]
 fn import_kind_serialization() {
     assert_eq!(serde_json::to_string(&ImportKind::Glob).unwrap(), "\"glob\"");
     assert_eq!(serde_json::to_string(&ImportKind::Module).unwrap(), "\"module\"");
 }
 
 #[test]
 fn module_kind_serialization() {
     assert_eq!(serde_json::to_string(&ModuleKind::Directory).unwrap(), "\"directory\"");
+    assert_eq!(serde_json::to_string(&ModuleKind::Inline).unwrap(), "\"inline\"");
+    assert_eq!(serde_json::to_string(&ModuleKind::Namespace).unwrap(), "\"namespace\"");
+}
+```
+
+**Adapter ReferenceKind:**
+```rust
+#[test]
+fn adapter_reference_kind() {
+    // Adapter ReferenceKind is separate from facts::ReferenceKind
+    // but the integration layer maps between them
+    use tugtool_core::adapter::ReferenceKind;
+
+    let kinds = [
+        ReferenceKind::Read,
+        ReferenceKind::Write,
+        ReferenceKind::Call,
+        ReferenceKind::Import,
+        ReferenceKind::Attribute,
+        ReferenceKind::TypeAnnotation,
+        ReferenceKind::Delete,
+    ];
+    assert_eq!(kinds.len(), 7);
 }
 ```
 
 **Schema Version Default:**
 ```rust
 #[test]
 fn facts_store_default_schema_version() {
     let store = FactsStore::new();
     assert_eq!(store.schema_version, FACTS_SCHEMA_VERSION);
     assert_eq!(FACTS_SCHEMA_VERSION, 11);
@@ -1825,46 +2028,52 @@ fn visibility_inference_public_dunder() {
 
 #### Step 2.5: Generalize Import and ModuleKind {#step-2-5}
 
 **Commit:** `feat(facts): generalize imports and modules`
 
 **References:** [D04] Import and Module Generalization, Concept C03, Concept C04, (#import-generalization)
 
 **Artifacts:**
 - `ImportKind` enum
 - `Import.kind` replacing `is_star`
-- Generalized `ModuleKind` (Directory, Namespace)
+- Builder pattern with auto-setting `ImportKind`
+- Generalized `ModuleKind` (Directory, Inline, Namespace)
 - Updated docs for module/import semantics
 
 **Tasks:**
 - [ ] Add `ImportKind` enum to `facts/mod.rs`
 - [ ] Replace `Import.is_star: bool` with `Import.kind: ImportKind`
-- [ ] Update `Import::new()` to set `ImportKind::Named` by default
-- [ ] **Migration:** Replace all `Import::with_star(true)` calls with `Import::with_kind(ImportKind::Glob)`
-- [ ] **Migration:** Replace all `Import::with_star(false)` calls with appropriate `ImportKind` variant
+- [ ] Update `Import::new()` to set `ImportKind::Module` by default (bare `import foo`)
+- [ ] Add `Import::with_imported_name()` - auto-sets `ImportKind::Named`
+- [ ] Add `Import::with_alias()` - auto-sets `ImportKind::Alias`
+- [ ] Add `Import::with_glob()` - sets `ImportKind::Glob` (replaces `with_star()`)
+- [ ] Add `Import::with_kind()` - explicit override for `ReExport`, `Default`, etc.
+- [ ] **Migration:** Replace all `Import::with_star()` calls with `Import::with_glob()`
 - [ ] Remove `Import::with_star()` builder method entirely
-- [ ] Add `Import::with_kind(kind: ImportKind) -> Self` builder method
 - [ ] **Migration:** Rename `ModuleKind::Package` to `ModuleKind::Directory`
+- [ ] Add `ModuleKind::Inline` variant (for Rust `mod foo { ... }`)
 - [ ] Add `ModuleKind::Namespace` variant
 - [ ] Update `ModuleKind` docs to remove `__init__.py` references
-- [ ] Update Python analyzer to emit correct `ImportKind`:
-  - `import foo` → `ImportKind::Module`
-  - `from foo import bar` → `ImportKind::Named`
-  - `from foo import bar as baz` → `ImportKind::Alias`
-  - `from foo import *` → `ImportKind::Glob`
+- [ ] Update Python analyzer to use new builder pattern:
+  - `import foo` → `Import::new("foo")` (kind = Module by default)
+  - `from foo import bar` → `Import::new("foo").with_imported_name("bar")` (auto-sets Named)
+  - `from foo import bar as baz` → `Import::new("foo").with_imported_name("bar").with_alias("baz")` (auto-sets Alias)
+  - `from foo import *` → `Import::new("foo").with_glob()` (sets Glob)
 - [ ] **Migration:** Update all callers that check `is_star` to check `kind == ImportKind::Glob`
 - [ ] Update any core queries/tests that rely on `is_star` or `ModuleKind::Package`
 
 **Tests:**
 - [ ] Unit: `ImportKind` serialization (all variants)
-- [ ] Unit: `ModuleKind` serialization (all variants)
-- [ ] Unit: `Import::with_kind` works correctly
+- [ ] Unit: `ModuleKind` serialization (all variants including `Inline`)
+- [ ] Unit: `Import::with_imported_name` auto-sets `ImportKind::Named`
+- [ ] Unit: `Import::with_alias` auto-sets `ImportKind::Alias`
+- [ ] Unit: `Import::with_glob` sets `ImportKind::Glob`
 - [ ] Integration: Python analyzer emits `ImportKind::Module` for `import foo`
 - [ ] Integration: Python analyzer emits `ImportKind::Named` for `from foo import bar`
 - [ ] Integration: Python analyzer emits `ImportKind::Alias` for `from foo import bar as baz`
 - [ ] Integration: Python analyzer emits `ImportKind::Glob` for `from foo import *`
 
 **Checkpoint:**
 - [ ] `cargo nextest run -p tugtool-core import`
 - [ ] `cargo nextest run -p tugtool-core module`
 - [ ] `cargo nextest run -p tugtool-python import`
 - [ ] `cargo clippy --workspace` (no unused code warnings for removed methods)
@@ -1920,98 +2129,110 @@ fn visibility_inference_public_dunder() {
 - [ ] `cargo nextest run -p tugtool-core public_export`
 - [ ] `cargo build -p tugtool-python` (compiles, legacy Export still exists)
 
 **Rollback:**
 - Revert commit
 
 **Commit after all checkpoints pass.**
 
 ---
 
-#### Step 3a: Remove Legacy Export Type {#step-3a}
-
-**Commit:** `refactor(facts): remove legacy Export type and ExportId`
-
-**References:** [D03] PublicExport for Language-Agnostic Exports, (#export-generalization)
-
-**Artifacts:**
-- Legacy `Export` type removed from FactsStore
-- Legacy `ExportId` newtype removed
-- Legacy export storage and queries removed
-
-**Tasks:**
-- [ ] **Remove legacy `ExportId` newtype** from FactsStore
-- [ ] **Remove legacy `Export` type** from FactsStore
-- [ ] **Remove legacy export storage**: `exports`, `exports_by_file`, `exports_by_name`
-- [ ] **Remove legacy export queries**: `export()`, `exports_in_file()`, `exports_named()`, `exports()`
-- [ ] **Remove `next_export_id()` generator**
-- [ ] Update any code in `tugtool-core` that references legacy `Export` or `ExportId`
-
-**Tests:**
-- [ ] Unit: Legacy types no longer exist (compile check)
-- [ ] Unit: PublicExport types still work correctly
-
-**Checkpoint:**
-- [ ] `cargo build -p tugtool-core` (compiles without legacy types)
-- [ ] `cargo nextest run -p tugtool-core public_export`
-
-**Rollback:**
-- Revert commit
-
-**Commit after all checkpoints pass.**
-
----
-
-#### Step 3b: Update Python Analyzer to Emit PublicExport {#step-3b}
+#### Step 3a: Update Python Analyzer to Emit PublicExport {#step-3a}
 
 **Commit:** `feat(python): emit PublicExport for __all__ exports`
 
 **References:** [D03] PublicExport for Language-Agnostic Exports, Concept C01, (#export-generalization)
 
+> **Sequencing Note:** This step adds PublicExport support BEFORE removing legacy Export.
+> Both export types coexist temporarily. This ensures each commit is buildable.
+
 **Artifacts:**
-- Python analyzer emits `PublicExport` instead of legacy `Export`
+- Python analyzer emits `PublicExport` in addition to legacy `Export`
 - Export spans populated correctly for rename operations
 
 **Tasks:**
-- [ ] Update Python analyzer to emit `PublicExport` instead of legacy `Export`
+- [ ] Update Python analyzer to emit `PublicExport` for each `__all__` entry
+- [ ] Keep legacy `Export` emission temporarily (removed in Step 3b)
 - [ ] Populate `export_kind: ExportKind::PythonAll` for `__all__` entries
 - [ ] Populate `export_target: ExportTarget::Single` for individual `__all__` entries
 - [ ] Populate `export_intent: ExportIntent::Declared` for explicit `__all__` declarations
 - [ ] Populate `export_origin: ExportOrigin::Local` for locally-defined exports
 - [ ] Populate `exported_name` and `source_name` (same for non-aliased Python exports)
 - [ ] Populate `exported_name_span` pointing at string content only (excluding quotes)
 - [ ] Populate `decl_span` covering the full string literal including quotes
 - [ ] Resolve `symbol_id` when the exported name matches a defined symbol
 
 **Span Semantics for Python `__all__`:**
 For `__all__ = ["foo", "bar"]`:
 - `decl_span` covers `"foo"` (full string literal with quotes, e.g., bytes 12-17)
 - `exported_name_span` covers `foo` (string content only, e.g., bytes 13-16)
 - This matches the legacy `content_span` semantics for rename-safe replacements
 
 **Tests:**
 - [ ] Unit: Python `__all__` parsing produces correct `PublicExport` fields
 - [ ] Unit: `exported_name_span` excludes quote characters
 - [ ] Unit: `decl_span` includes quote characters
 - [ ] Integration: Python analyzer correctly resolves `symbol_id` for exported names
+- [ ] Integration: Both legacy Export and PublicExport are populated (temporary)
 
 **Checkpoint:**
 - [ ] `cargo nextest run -p tugtool-python export`
 - [ ] `cargo nextest run -p tugtool-python`
 
 **Rollback:**
 - Revert commit
 
 **Commit after all checkpoints pass.**
 
 ---
 
+#### Step 3b: Remove Legacy Export Type {#step-3b}
+
+**Commit:** `refactor(facts): remove legacy Export type and ExportId`
+
+**References:** [D03] PublicExport for Language-Agnostic Exports, (#export-generalization)
+
+> **Sequencing Note:** This step removes legacy Export AFTER PublicExport is fully working.
+> Python analyzer was updated in Step 3a; this step cleans up the old types.
+
+**Artifacts:**
+- Legacy `Export` type removed from FactsStore
+- Legacy `ExportId` newtype removed
+- Legacy export storage and queries removed
+- Python analyzer no longer emits legacy `Export`
+
+**Tasks:**
+- [ ] **Remove legacy `ExportId` newtype** from FactsStore
+- [ ] **Remove legacy `Export` type** from FactsStore
+- [ ] **Remove legacy export storage**: `exports`, `exports_by_file`, `exports_by_name`
+- [ ] **Remove legacy export queries**: `export()`, `exports_in_file()`, `exports_named()`, `exports()`
+- [ ] **Remove `next_export_id()` generator**
+- [ ] Remove legacy `Export` emission from Python analyzer (added temporarily in Step 3a)
+- [ ] Update any code in `tugtool-core` that references legacy `Export` or `ExportId`
+
+**Tests:**
+- [ ] Unit: Legacy types no longer exist (compile check)
+- [ ] Unit: PublicExport types still work correctly
+- [ ] Integration: Python analyzer only emits PublicExport
+
+**Checkpoint:**
+- [ ] `cargo build -p tugtool-core` (compiles without legacy types)
+- [ ] `cargo nextest run -p tugtool-core public_export`
+- [ ] `cargo nextest run -p tugtool-python`
+
+**Rollback:**
+- Revert commit
+
+**Commit after all checkpoints pass.**
+
+---
+
 #### Step 3c: Update Rename Operations for PublicExport {#step-3c}
 
 **Commit:** `refactor(python): use PublicExport in rename operations`
 
 **References:** [D03] PublicExport for Language-Agnostic Exports, (#export-generalization)
 
 **Artifacts:**
 - Rename operations use `PublicExport` queries and name spans
 - Export edits use `exported_name_span` for precise replacement
 
@@ -2033,21 +2254,29 @@ For `__all__ = ["foo", "bar"]`:
 
 **Rollback:**
 - Revert commit
 
 **Commit after all checkpoints pass.**
 
 ---
 
 #### Step 3 Summary {#step-3-summary}
 
-After completing Steps 3, 3a, 3b, and 3c, you will have:
+**Execution Order:** Step 3 → Step 3a → Step 3b → Step 3c
+
+Each step is a buildable commit:
+1. **Step 3:** Add `PublicExport` type to FactsStore (new type exists alongside legacy)
+2. **Step 3a:** Update Python analyzer to emit `PublicExport` (both types emitted temporarily)
+3. **Step 3b:** Remove legacy `Export` and `ExportId` (clean break, only `PublicExport` remains)
+4. **Step 3c:** Update rename operations to use `PublicExport` queries
+
+After completing all steps, you will have:
 - `PublicExport` as the canonical export model in FactsStore
 - Legacy `Export` and `ExportId` types completely removed
 - Python analyzer emitting `PublicExport` with correct spans and metadata
 - Rename operations using `PublicExport` for precise export edits
 
 **Final Step 3 Checkpoint:**
 - [ ] `cargo nextest run --workspace` (all export-related tests pass)
 
 ---
 
