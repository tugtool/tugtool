# rmcp 0.12 MCP Server Implementation Specification

## Overview

This document provides verified, working patterns for implementing MCP (Model Context Protocol) servers using the `rmcp` crate version 0.12. All patterns have been validated against the official [modelcontextprotocol/rust-sdk](https://github.com/modelcontextprotocol/rust-sdk) repository.

## Cargo.toml Dependencies

```toml
[dependencies]
# MCP server support
rmcp = { version = "0.12", features = ["server", "transport-io"] }
schemars = "1"  # Required for JsonSchema derive on tool parameters
serde = { version = "1", features = ["derive"] }
tokio = { version = "1", features = ["full"] }

# Optional but recommended
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
```

### Feature Flags Explained

| Feature | Purpose |
|---------|---------|
| `server` | Enables server-side functionality including `ServerHandler`, `ToolRouter`, and tool macros |
| `transport-io` | Enables `stdio()` transport for stdin/stdout communication |
| `macros` | Enabled by default - provides `#[tool]`, `#[tool_router]`, `#[tool_handler]` macros |
| `schemars` | Re-exports schemars for convenience (optional - you can depend on schemars directly) |

### Version Compatibility

- `rmcp` 0.12.x requires `schemars` version 1.x (NOT 0.8.x)
- `tokio` 1.x is required for async runtime
- `serde` 1.x for serialization

## Core Imports

```rust
use rmcp::{
    // Core traits and types
    ServerHandler,
    ServiceExt,
    ErrorData as McpError,  // Type alias for MCP errors

    // Server infrastructure
    handler::server::{
        router::tool::ToolRouter,
        wrapper::Parameters,  // CRITICAL: Parameter wrapper for tools
    },

    // Model types
    model::{
        CallToolResult,
        Content,
        Implementation,
        ProtocolVersion,
        ServerCapabilities,
        ServerInfo,
    },

    // Transport
    transport::stdio,

    // Macros (re-exported at crate root)
    tool,
    tool_handler,
    tool_router,
    schemars,  // Re-exported from rmcp when schemars feature is enabled
};
```

**Important:** You can use `rmcp::schemars` if you have the `schemars` feature enabled, or depend on `schemars` directly in your Cargo.toml. Both work.

## Tool Parameter Definition

### The Parameters Wrapper (CRITICAL)

Tool parameters MUST be wrapped in `Parameters<T>` where `T` is your parameter struct. This is the most common source of errors.

```rust
use rmcp::handler::server::wrapper::Parameters;

// Your parameter struct - derives are REQUIRED
#[derive(Debug, serde::Deserialize, schemars::JsonSchema)]
pub struct MyToolParams {
    /// Description for the JSON schema (shown to LLM)
    #[schemars(description = "What this parameter does")]
    pub required_field: String,

    /// Optional fields use Option<T>
    #[serde(skip_serializing_if = "Option::is_none")]
    pub optional_field: Option<i32>,
}

// In your tool implementation, use destructuring pattern:
#[tool(description = "Does something useful")]
fn my_tool(
    &self,
    Parameters(MyToolParams { required_field, optional_field }): Parameters<MyToolParams>,
) -> Result<CallToolResult, McpError> {
    // Use required_field and optional_field directly
    Ok(CallToolResult::success(vec![Content::text("result")]))
}
```

### Required Derives for Parameter Structs

| Derive | Purpose |
|--------|---------|
| `serde::Deserialize` | Required - parses JSON arguments from tool call |
| `schemars::JsonSchema` | Required - generates JSON Schema for tool discovery |
| `Debug` | Recommended - useful for debugging |
| `Clone` | Optional - only if you need to clone parameters |

### The `#[schemars(description = "...")]` Attribute

Use this on struct fields to provide descriptions that appear in the JSON Schema. LLMs see these descriptions when discovering tools.

```rust
#[derive(Debug, serde::Deserialize, schemars::JsonSchema)]
pub struct RenameParams {
    /// The original name to find
    #[schemars(description = "The current name of the symbol to rename")]
    pub old_name: String,

    /// The new name to use
    #[schemars(description = "The new name for the symbol")]
    pub new_name: String,

    /// Optional scope restriction
    #[schemars(description = "Limit renaming to this directory (optional)")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scope: Option<String>,
}
```

## Server Implementation Pattern

### Step 1: Define Your Server Struct

```rust
#[derive(Clone)]
pub struct MyServer {
    // ToolRouter is REQUIRED and must be typed with Self
    tool_router: ToolRouter<Self>,

    // Add any state your server needs
    state: Arc<Mutex<MyState>>,
}
```

### Step 2: Implement Tools with `#[tool_router]`

```rust
#[tool_router]
impl MyServer {
    /// Constructor MUST call Self::tool_router() to initialize the router
    pub fn new() -> Self {
        Self {
            tool_router: Self::tool_router(),  // Generated by #[tool_router]
            state: Arc::new(Mutex::new(MyState::default())),
        }
    }

    // Tool without parameters - simplest form
    #[tool(description = "Get current status")]
    async fn get_status(&self) -> Result<CallToolResult, McpError> {
        let state = self.state.lock().await;
        Ok(CallToolResult::success(vec![Content::text(
            format!("Status: {:?}", state)
        )]))
    }

    // Tool with parameters - use Parameters wrapper
    #[tool(description = "Set a value")]
    async fn set_value(
        &self,
        Parameters(params): Parameters<SetValueParams>,
    ) -> Result<CallToolResult, McpError> {
        let mut state = self.state.lock().await;
        state.value = params.value;
        Ok(CallToolResult::success(vec![Content::text("Value set")]))
    }

    // Synchronous tool - also supported
    #[tool(description = "Echo input")]
    fn echo(
        &self,
        Parameters(EchoParams { message }): Parameters<EchoParams>,
    ) -> Result<CallToolResult, McpError> {
        Ok(CallToolResult::success(vec![Content::text(
            format!("Echo: {}", message)
        )]))
    }
}
```

### Step 3: Implement ServerHandler with `#[tool_handler]`

```rust
#[tool_handler]
impl ServerHandler for MyServer {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            protocol_version: ProtocolVersion::V_2024_11_05,
            capabilities: ServerCapabilities::builder()
                .enable_tools()
                .build(),
            server_info: Implementation {
                name: "my-server".to_string(),
                version: env!("CARGO_PKG_VERSION").to_string(),
                title: Some("My MCP Server".to_string()),
                icons: None,
                website_url: None,
            },
            instructions: Some(
                "Description of your server for the LLM".to_string()
            ),
        }
    }
}
```

### Step 4: Main Entry Point

```rust
use rmcp::{ServiceExt, transport::stdio};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize logging (writes to stderr to avoid stdio collision)
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::from_default_env()
                .add_directive(tracing::Level::DEBUG.into())
        )
        .with_writer(std::io::stderr)
        .with_ansi(false)
        .init();

    tracing::info!("Starting MCP server");

    // Create and start server
    let service = MyServer::new()
        .serve(stdio())
        .await?;

    // Block until client disconnects or sends shutdown
    service.waiting().await?;

    Ok(())
}
```

## Return Types

### CallToolResult

```rust
// Success with text content
Ok(CallToolResult::success(vec![Content::text("your output here")]))

// Success with multiple content items
Ok(CallToolResult::success(vec![
    Content::text("First part"),
    Content::text("Second part"),
]))

// Error result (tool executed but encountered a logical error)
Ok(CallToolResult::error(vec![Content::text("Error: something went wrong")]))

// Structured JSON result
Ok(CallToolResult::structured(serde_json::json!({
    "result": "value",
    "count": 42
})))
```

### McpError

For protocol-level errors (not tool execution errors):

```rust
use rmcp::ErrorData as McpError;

// Invalid parameters
Err(McpError::invalid_params("description", Some(json!({"detail": "..."}))))

// Resource not found
Err(McpError::resource_not_found("resource_id", Some(json!({"uri": "..."}))))

// Internal error
Err(McpError::internal_error("description", Some(json!({"cause": "..."}))))
```

## Simplified Return Types

Tools can return simpler types that automatically convert:

```rust
// Returns String directly - automatically wrapped in CallToolResult::success
#[tool(description = "Calculate sum")]
fn sum(
    &self,
    Parameters(SumParams { a, b }): Parameters<SumParams>,
) -> String {
    (a + b).to_string()
}

// This is equivalent to:
#[tool(description = "Calculate sum")]
fn sum(
    &self,
    Parameters(SumParams { a, b }): Parameters<SumParams>,
) -> Result<CallToolResult, McpError> {
    Ok(CallToolResult::success(vec![Content::text((a + b).to_string())]))
}
```

## Complete Minimal Example

```rust
//! Minimal MCP server example

use rmcp::{
    handler::server::{router::tool::ToolRouter, wrapper::Parameters},
    model::{CallToolResult, Content, Implementation, ProtocolVersion, ServerCapabilities, ServerInfo},
    tool, tool_handler, tool_router,
    transport::stdio,
    ErrorData as McpError, ServerHandler, ServiceExt,
};

#[derive(Debug, serde::Deserialize, schemars::JsonSchema)]
pub struct EchoParams {
    #[schemars(description = "Message to echo back")]
    pub message: String,
}

#[derive(Clone)]
pub struct EchoServer {
    tool_router: ToolRouter<Self>,
}

#[tool_router]
impl EchoServer {
    pub fn new() -> Self {
        Self {
            tool_router: Self::tool_router(),
        }
    }

    #[tool(description = "Echo input for testing MCP connectivity")]
    fn echo(
        &self,
        Parameters(EchoParams { message }): Parameters<EchoParams>,
    ) -> Result<CallToolResult, McpError> {
        Ok(CallToolResult::success(vec![Content::text(format!(
            "Echo: {}",
            message
        ))]))
    }
}

#[tool_handler]
impl ServerHandler for EchoServer {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            protocol_version: ProtocolVersion::V_2024_11_05,
            capabilities: ServerCapabilities::builder().enable_tools().build(),
            server_info: Implementation {
                name: "echo-server".to_string(),
                version: "0.1.0".to_string(),
                title: None,
                icons: None,
                website_url: None,
            },
            instructions: Some("A simple echo server for testing".to_string()),
        }
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt()
        .with_writer(std::io::stderr)
        .with_ansi(false)
        .init();

    let service = EchoServer::new().serve(stdio()).await?;
    service.waiting().await?;
    Ok(())
}
```

## Common Gotchas and Fixes

### 1. "IntoToolRoute not implemented" Error

**Cause:** Parameters not wrapped in `Parameters<T>`

**Wrong:**
```rust
#[tool(description = "...")]
fn my_tool(&self, params: MyParams) -> Result<CallToolResult, McpError> { ... }
```

**Correct:**
```rust
#[tool(description = "...")]
fn my_tool(&self, Parameters(params): Parameters<MyParams>) -> Result<CallToolResult, McpError> { ... }
```

### 2. "#[tool(aggr)]" Does Not Exist

**Cause:** Using outdated syntax

**Wrong:**
```rust
#[tool(description = "...")]
fn my_tool(&self, #[tool(aggr)] params: MyParams) -> ... { ... }
```

**Correct:**
```rust
#[tool(description = "...")]
fn my_tool(&self, Parameters(params): Parameters<MyParams>) -> ... { ... }
```

### 3. schemars Version Mismatch

**Cause:** Using schemars 0.8.x with rmcp 0.12

**Wrong:**
```toml
schemars = "0.8"  # Won't work with rmcp 0.12
```

**Correct:**
```toml
schemars = "1"  # Required for rmcp 0.12
```

### 4. Server Struct Not Clone

**Cause:** Server struct must implement Clone for the framework

**Fix:** Add `#[derive(Clone)]` to your server struct. For interior mutability, use `Arc<Mutex<T>>` or `Arc<RwLock<T>>`.

### 5. Missing tool_router Initialization

**Cause:** Not calling `Self::tool_router()` in constructor

**Fix:** The `#[tool_router]` macro generates a `Self::tool_router()` method. You MUST call it in your constructor to initialize the `tool_router` field.

### 6. Logging Interferes with stdio

**Cause:** Writing to stdout (which is used for JSON-RPC)

**Fix:** Always configure logging to write to stderr:
```rust
tracing_subscriber::fmt()
    .with_writer(std::io::stderr)
    .init();
```

## Testing Your Server

### Using the MCP Inspector

```bash
npx @modelcontextprotocol/inspector cargo run --features mcp -- mcp
```

### Programmatic Testing

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn server_creates_successfully() {
        let server = MyServer::new();
        let info = server.get_info();
        assert_eq!(info.server_info.name, "my-server");
    }

    #[test]
    fn server_has_tools_capability() {
        let server = MyServer::new();
        let info = server.get_info();
        assert!(info.capabilities.tools.is_some());
    }
}
```

## Sources

- [Official rust-sdk Repository](https://github.com/modelcontextprotocol/rust-sdk)
- [rmcp on docs.rs](https://docs.rs/rmcp/0.12.0/rmcp/)
- [rmcp on crates.io](https://crates.io/crates/rmcp)
- [Shuttle MCP Server Guide](https://www.shuttle.dev/blog/2025/07/18/how-to-build-a-stdio-mcp-server-in-rust)
- [MCPcat Rust Guide](https://mcpcat.io/guides/building-mcp-server-rust/)
