Claude CLI stream-json Protocol Reference
==========================================

Date: 2026-02-17
Method: Empirical testing against claude CLI v2.1.38 + reverse-engineering Agent SDK v0.2.44 source.
Every finding backed by actual CLI output or SDK source code — no assumptions.


1. Spawning the Process
=======================

The official Agent SDK spawns claude with:

  claude --output-format stream-json --input-format stream-json --verbose

The -p / --print flag is NOT required despite --help saying otherwise. The SDK omits
it. Empirically verified: the presence of --input-format stream-json implies
non-interactive mode. The process stays alive reading NDJSON from stdin.

Required flags:
  --output-format stream-json     NDJSON on stdout
  --input-format stream-json      NDJSON on stdin (implies non-interactive)
  --verbose                       Required for stream-json output

Optional flags:
  --model <model>                 Set model (default: sonnet)
  --resume <session_id>           Resume existing session (pass ID directly)
  -c, --continue                  Continue most recent conversation
  --fork-session                  Fork from resumed session (new ID, same history)
  --from-pr [value]               Resume session linked to a PR
  --session-id <uuid>             Use specific session ID (instead of auto-generated)
  --permission-mode <mode>        default | acceptEdits | bypassPermissions | plan |
                                    dontAsk | delegate
  --permission-prompt-tool stdio  Route permission prompts to stdin/stdout control protocol
  --include-partial-messages      Enable streaming deltas (stream_event messages)
  --replay-user-messages          Echo user messages back on stdout (adds isReplay field)
  --plugin-dir <path>             Load plugins
  --max-turns <n>                 Limit agentic turns
  --max-budget-usd <n>            Limit API spend
  --effort <level>                Reasoning effort: low, medium, high
  --fallback-model <model>        Fallback model when default is overloaded
  --allowedTools <list>           Comma-separated tools to auto-allow
  --disallowedTools <list>        Comma-separated tools to deny
  --tools <tools>                 Available tools ("" = none, "default" = all, or names)
  --dangerously-skip-permissions  Skip all permission checks (no control_request flow)
  --system-prompt <text>          Override system prompt entirely
  --append-system-prompt <text>   Add to system prompt
  --add-dir <paths>               Additional directories to allow access to
  --mcp-config <configs>          Load MCP server configurations
  --settings <file-or-json>       Load settings from JSON file or string
  --agents <json>                 Inline agent definitions (JSON object)
  --agent <agent>                 Set main agent for the session
  --json-schema <schema>          Structured output validation schema
  --no-session-persistence        Don't save sessions to disk
  --disable-slash-commands        Disable all skills/slash commands


2. Stdin → CLI (Messages You Send)
==================================

All stdin is NDJSON — one JSON object per line.

2a. User Message
----------------
  {
    "type": "user",
    "session_id": "",
    "message": {
      "role": "user",
      "content": [
        {"type": "text", "text": "your message here"}
      ]
    },
    "parent_tool_use_id": null
  }

  - session_id: always "" (empty string)
  - content: array of content blocks (see §8 for image/file content)
  - content as plain string also accepted: "content": "hello"
  - parent_tool_use_id: null for top-level messages
  - Slash commands (e.g. /cost, /compact) sent as regular user messages

2b. Control Request → CLI (interrupt)
-------------------------------------
  {
    "request_id": "<unique-id>",
    "type": "control_request",
    "request": {"subtype": "interrupt"}
  }

  CLI responds on stdout:
    {"type":"control_response","response":{"subtype":"success","request_id":"<id>"}}
  Then emits:
    user message: "[Request interrupted by user]"
    result: subtype="error_during_execution"

2c. Control Request → CLI (set permission mode)
------------------------------------------------
  {"request_id":"<id>","type":"control_request","request":{"subtype":"set_permission_mode","mode":"acceptEdits"}}

2d. Control Request → CLI (set model)
--------------------------------------
  {"request_id":"<id>","type":"control_request","request":{"subtype":"set_model","model":"claude-opus-4-6"}}

2e. Control Request → CLI (stop subagent task)
----------------------------------------------
  {"request_id":"<id>","type":"control_request","request":{"subtype":"stop_task","task_id":"..."}}

2f. Control Response → CLI (answering permission prompts)
---------------------------------------------------------
When the CLI sends a control_request on stdout asking for tool permission (§5),
respond with:

  Allow:
  {
    "type": "control_response",
    "response": {
      "subtype": "success",
      "request_id": "<from the control_request>",
      "response": {
        "behavior": "allow",
        "updatedInput": { <original tool input, possibly modified> }
      }
    }
  }

  Deny:
  {
    "type": "control_response",
    "response": {
      "subtype": "success",
      "request_id": "<from the control_request>",
      "response": {
        "behavior": "deny",
        "message": "User denied this action"
      }
    }
  }

  IMPORTANT: The response object must match the PermissionResult Zod schema.
  - behavior: "allow" requires updatedInput (record/object)
  - behavior: "deny" requires message (string)
  - {decision: "allow"} does NOT work — will fail Zod validation


3. Stdout ← CLI (Messages You Receive)
=======================================

All stdout is NDJSON. Top-level "type" field determines the message kind.

  type               | description
  -------------------|--------------------------------------------------
  system             | Session init, compact boundaries
  assistant          | Complete assistant message (NOT wrapped in stream_event)
  user               | Tool results, replayed user messages, slash command output
  result             | Turn complete (success or error)
  stream_event       | Streaming delta wrapper (only with --include-partial-messages)
  control_request    | Permission prompt / question FROM CLI (must respond)
  control_response   | CLI's response to YOUR control_request
  control_cancel_request | Cancel a pending control_request
  keep_alive         | Heartbeat (ignore)

3a. system
----------
  {
    "type": "system",
    "subtype": "init",
    "session_id": "uuid",
    "cwd": "/working/dir",
    "tools": ["Task","Bash","Read","Edit","Write","Glob","Grep",...],
    "model": "claude-sonnet-4-5-20250929",
    "permissionMode": "default",
    "slash_commands": ["compact","cost","review",...],
    "skills": ["keybindings-help","debug",...],
    "agents": ["Bash","general-purpose","Explore",...],
    "plugins": [{"name":"tugtool","path":"/path/to/plugin"}],
    "mcp_servers": [],
    "claude_code_version": "2.1.38",
    "output_style": "default",
    "fast_mode_state": "off",
    "apiKeySource": "ANTHROPIC_API_KEY"
  }

  - Emitted at the START OF EVERY TURN, not just the first
  - session_id is consistent across turns in the same session
  - Also emitted with subtype "compact_boundary" after context compaction

  Web frontend uses: tools (show available tools), slash_commands (autocomplete),
  model (display), permissionMode (display), session_id (for resume), plugins,
  agents, skills, claude_code_version.

3b. assistant
-------------
  {
    "type": "assistant",
    "session_id": "uuid",
    "parent_tool_use_id": null,
    "message": {
      "model": "claude-sonnet-4-5-20250929",
      "id": "msg_xxx",
      "role": "assistant",
      "content": [
        {"type": "text", "text": "I'll help you with that."},
        {"type": "tool_use", "id": "toolu_xxx", "name": "Read", "input": {"file_path": "/tmp/foo"}}
      ],
      "stop_reason": null,
      "usage": { "input_tokens": 3, "output_tokens": 42, ... }
    }
  }

  - Content is an array of blocks: text and/or tool_use
  - With --include-partial-messages: emitted for each completed content block
    (so you may see multiple assistant messages per turn, each with partial content)
  - WITHOUT --include-partial-messages: emitted once with complete content

3c. user
--------
  Tool result:
  {
    "type": "user",
    "session_id": "uuid",
    "message": {
      "role": "user",
      "content": [
        {
          "type": "tool_result",
          "tool_use_id": "toolu_xxx",
          "content": "file contents here...",
          "is_error": false
        }
      ]
    }
  }

  Replayed user message (with --replay-user-messages):
  {
    "type": "user",
    "session_id": "uuid",
    "isReplay": true,
    "message": {"role": "user", "content": [{"type": "text", "text": "original prompt"}]}
  }

  Slash command output (e.g. /cost):
  {
    "type": "user",
    "isReplay": true,
    "message": {
      "role": "user",
      "content": "<local-command-stdout>Total cost: $0.04\n...</local-command-stdout>"
    }
  }

3d. result
----------
  Success:
  {
    "type": "result",
    "subtype": "success",
    "session_id": "uuid",
    "is_error": false,
    "result": "final text response",
    "total_cost_usd": 0.042,
    "num_turns": 2,
    "duration_ms": 5000,
    "duration_api_ms": 4800,
    "usage": { "input_tokens": 100, "output_tokens": 50, ... },
    "modelUsage": { "claude-sonnet-4-5": { "inputTokens": 100, "outputTokens": 50, "costUSD": 0.042 } },
    "permission_denials": []
  }

  Error subtypes:
    "success"                          Normal completion
    "error_during_execution"           Runtime error or interrupt
    "error_max_turns"                  Hit --max-turns limit
    "error_max_budget_usd"             Hit --max-budget-usd limit
    "error_max_structured_output_retries"  Schema validation failed too many times

  permission_denials: Array of {tool_name, tool_use_id, tool_input} for denied tools.

3e. stream_event (only with --include-partial-messages)
-------------------------------------------------------
  {
    "type": "stream_event",
    "session_id": "uuid",
    "parent_tool_use_id": null,
    "event": { <raw Anthropic API streaming event> }
  }

  event.type values:
    message_start       New message: event.message has model, role, etc.
    content_block_start New block: event.content_block.type = "text" | "tool_use"
                        For tool_use: event.content_block.name = "Read", etc.
    content_block_delta Streaming delta:
                          text:    event.delta.type = "text_delta", event.delta.text
                          tool:    event.delta.type = "input_json_delta", event.delta.partial_json
    content_block_stop  Block complete: event.index
    message_delta       Message update: event.delta.stop_reason, event.usage
    message_stop        Message fully complete


4. Turn Lifecycle
=================

Simple text response (no streaming):
  system(init) → assistant(complete) → result

Simple text response (with streaming):
  system(init) → stream_event(message_start) → stream_event(block_start/text) →
  stream_event(delta/text) ×N → assistant(complete text) → stream_event(block_stop) →
  stream_event(message_delta) → stream_event(message_stop) → result

Tool use (with streaming):
  system(init) → [text streaming if any] → assistant(text block) →
  stream_event(block_start/tool_use) → stream_event(delta/json) ×N →
  assistant(tool_use block) → stream_event(block_stop) →
  user(tool_result) → [CLI may loop for more tool calls or final response] → result

Multi-turn (user sends another message after result):
  [result from previous turn] → [user writes new message to stdin] →
  system(init) → ... → result

Key observation: the assistant message for each content block is emitted BEFORE
the content_block_stop stream_event. This means you can use the assistant message
as the "here's the complete block" signal.


5. Permission Prompt Flow (--permission-prompt-tool stdio)
==========================================================

When using --permission-prompt-tool stdio, the CLI routes all tool permission
decisions through the stdin/stdout control protocol instead of the interactive
terminal UI.

5a. Tool Permission Request
---------------------------
When Claude wants to use a tool that requires permission:

  CLI → stdout:
  {
    "type": "control_request",
    "request_id": "uuid",
    "request": {
      "subtype": "can_use_tool",
      "tool_name": "Bash",
      "input": {
        "command": "rm /tmp/foo.txt",
        "description": "Remove file"
      },
      "tool_use_id": "toolu_xxx",
      "permission_suggestions": [
        {
          "type": "addDirectories",
          "directories": ["/private/tmp"],
          "destination": "session"
        },
        {
          "type": "setMode",
          "mode": "acceptEdits",
          "destination": "session"
        }
      ],
      "decision_reason": "Path is outside allowed working directories",
      "blocked_path": "/private/tmp/foo.txt"
    }
  }

  Fields for web frontend:
  - tool_name: which tool (Bash, Read, Edit, Write, etc.)
  - input: full tool input (show to user)
  - decision_reason: why permission is needed (display)
  - blocked_path: specific path that was blocked (optional, for filesystem tools)
  - permission_suggestions: rules the user could add to auto-allow in future
    - type: "addRules" | "addDirectories" | "setMode"
    - destination: "session" | "projectSettings" | "userSettings"
    - For addRules: rules = [{toolName, ruleContent}]
    - For addDirectories: directories = ["/path"]
    - For setMode: mode = "acceptEdits" | "bypassPermissions"

  Respond with allow or deny (§2f).

5b. AskUserQuestion Flow
-------------------------
AskUserQuestion is handled EXACTLY like a tool permission request:

  CLI → stdout:
  {
    "type": "control_request",
    "request_id": "uuid",
    "request": {
      "subtype": "can_use_tool",
      "tool_name": "AskUserQuestion",
      "input": {
        "questions": [
          {
            "question": "What is your favorite color?",
            "header": "Color",
            "multiSelect": false,
            "options": [
              {"label": "Red", "description": "A warm color"},
              {"label": "Blue", "description": "A cool color"},
              {"label": "Green", "description": "A natural color"}
            ]
          }
        ]
      },
      "tool_use_id": "toolu_xxx"
    }
  }

  To answer, respond with behavior: "allow" and inject "answers" into updatedInput:
  {
    "type": "control_response",
    "response": {
      "subtype": "success",
      "request_id": "<from request>",
      "response": {
        "behavior": "allow",
        "updatedInput": {
          "questions": [ ... same questions ... ],
          "answers": {
            "What is your favorite color?": "Blue"
          }
        }
      }
    }
  }

  The answers map: question text → selected option label.
  For multiSelect questions, comma-separate the labels: "Red,Blue"

  After responding, the CLI passes the answer to Claude as a tool_result:
    "User has answered your questions: 'What is your favorite color?'='Blue'"

  Web frontend: render a form with the questions/options, collect answers,
  send control_response with the answers map.


6. Slash Commands
=================

Slash commands are sent as regular user messages:
  {"type":"user","message":{"role":"user","content":[{"type":"text","text":"/cost"}]}}

The output comes back as a user message with isReplay:true and content wrapped in
<local-command-stdout> tags:
  {"type":"user","isReplay":true,"message":{"role":"user","content":"<local-command-stdout>Total cost: $0.04...</local-command-stdout>"}}
  {"type":"result","subtype":"success","result":""}

Available slash commands are listed in the system init message under "slash_commands".

Built-in commands: compact, context, cost, init, pr-comments, release-notes,
review, security-review, insights.

Plugin/skill commands: any skill loaded via --plugin-dir or registered skills.

Web frontend: show autocomplete from system.slash_commands when user types /.
Send as regular message. Parse <local-command-stdout> tags in response.


7. Session Management
=====================

7a. New Session
---------------
Omit --resume. CLI creates a new session and returns session_id in the system init.

7b. Resume Session
------------------
  claude --resume <session_id> --output-format stream-json --input-format stream-json --verbose

The session remembers full conversation history. session_id is from system init.
Session-scoped permissions are NOT restored on resume — user must re-approve.

7c. Continue Most Recent
------------------------
  claude --continue --output-format stream-json --input-format stream-json --verbose

Picks up the most recent session. Equivalent to --resume with the latest session ID.

7d. Fork Session
----------------
  claude --continue --fork-session --output-format stream-json ...

Creates a NEW session ID while preserving conversation history up to that point.
The original session is unchanged. Useful for branching: "try a different approach"
without affecting the original conversation.

Web frontend: offer "Fork" button on any session to create an alternate timeline.
The system init will have a new session_id.

7e. Session ID Capture
----------------------
From the first system message:
  if (msg.type === "system" && msg.subtype === "init") {
    sessionId = msg.session_id;
  }

The session_id appears on most messages, but the canonical source is system/init.

7f. Session Listing
-------------------
Sessions are stored locally by the CLI. To list/manage sessions, use:
  claude --resume (interactive session picker in TUI mode)

For a web frontend, maintain your own session registry using the session_id
values from system init messages.


8. File and Image Attachments
=============================

8a. @file Reference (CLI feature)
----------------------------------
Include @/path/to/file in the message text. The CLI reads the file and injects
its content as context. Works for both text files and images.

  {"type":"user","message":{"role":"user","content":[
    {"type":"text","text":"@/tmp/readme.txt summarize this file"}
  ]}}

  {"type":"user","message":{"role":"user","content":[
    {"type":"text","text":"@/tmp/screenshot.png what do you see?"}
  ]}}

  The CLI handles the file reading — Claude receives the content directly.

8b. Direct Image Content Block (for web uploads)
-------------------------------------------------
For drag-and-drop, paste, or file upload in a web frontend, send images as
base64 content blocks in the message content array:

  {
    "type": "user",
    "session_id": "",
    "message": {
      "role": "user",
      "content": [
        {"type": "text", "text": "What do you see in this image?"},
        {
          "type": "image",
          "source": {
            "type": "base64",
            "media_type": "image/png",
            "data": "<base64-encoded-image-data>"
          }
        }
      ]
    },
    "parent_tool_use_id": null
  }

  Supported media types: image/png, image/jpeg, image/gif, image/webp
  Maximum image size: follows Anthropic API limits (~5MB)

8c. Multiple Content Blocks
----------------------------
A single message can mix text and images:
  content: [
    {"type": "text", "text": "Compare these two images:"},
    {"type": "image", "source": {"type": "base64", "media_type": "image/png", "data": "..."}},
    {"type": "image", "source": {"type": "base64", "media_type": "image/png", "data": "..."}}
  ]


9. Tool Use Display for Web Frontend
=====================================

Tool results appear in two places on the user message envelope:
  1. tool_result.content — simple text string (sent to the model)
  2. tool_use_result — structured metadata on the outer message (for UI rendering)

The web frontend should use tool_use_result for rich rendering when available.

9a. Read Tool
-------------
  Input: {file_path: "/path/to/file", offset?: N, limit?: N}
  Result content: numbered file content (cat -n format)
  Web: show file content viewer with syntax highlighting

9b. Edit Tool
-------------
  Input: {file_path, old_string, new_string, replace_all?}
  Result content: "The file /path/to/file has been updated successfully."

  Structured tool_use_result (on outer user message envelope):
  {
    "tool_use_result": {
      "filePath": "/tmp/file.txt",
      "oldString": "old text here",
      "newString": "new text here",
      "originalFile": "line 1\nline 2\nold text here\nline 4\n",
      "structuredPatch": [
        {
          "oldStart": 1,
          "oldLines": 4,
          "newStart": 1,
          "newLines": 4,
          "lines": [
            " line 1",
            " line 2",
            "-old text here",
            "+new text here",
            " line 4"
          ]
        }
      ],
      "userModified": false,
      "replaceAll": false
    }
  }

  structuredPatch: array of unified-diff hunks. Each hunk has:
    - oldStart/oldLines: position in original file
    - newStart/newLines: position in modified file
    - lines: prefixed with " " (context), "-" (removed), "+" (added)

  originalFile: full file content BEFORE the edit.
  userModified: whether the user modified the input via updatedInput in the
    permission response (see §2f).

  Web: render a full diff view using structuredPatch. Show file path header.
  The control_request for Edit includes old_string and new_string — render
  a diff preview BEFORE the user approves.

  Error case (file not read yet):
    tool_result.is_error = true
    tool_result.content = "<tool_use_error>File has not been read yet.
      Read it first before writing to it.</tool_use_error>"
    tool_use_result = "Error: File has not been read yet..."

9c. Write Tool
--------------
  Input: {file_path, content}
  Result content: "File created successfully at: /path/to/file"

  Structured tool_use_result (on outer user message envelope):
  {
    "tool_use_result": {
      "type": "create",
      "filePath": "/tmp/file.txt",
      "content": "Hello World\nLine 2\nLine 3",
      "structuredPatch": [],
      "originalFile": null
    }
  }

  For new files: type="create", originalFile=null, structuredPatch=[].
  For overwrites: type="overwrite", originalFile=<previous content>,
    structuredPatch contains the diff hunks.

  Web: for new files, show full content with syntax highlighting.
  For overwrites, show diff using structuredPatch (same format as Edit).
  For permission, show full content to be written.

9d. Bash Tool
-------------
  Input: {command, description?, timeout?}
  Result content: command stdout/stderr text
  tool_use_result: plain string (same as content, no structured data)
  Web: show terminal-style output. Use description field for quick summary.
  Non-zero exit codes set is_error: true and prepend "Exit code N\n" to content.

9e. Glob/Grep Tools
--------------------
  Input: {pattern, path?} / {pattern, path?, type?, output_mode?}
  Result: matching file paths or content
  Web: show file list or search results

9f. WebFetch/WebSearch
-----------------------
  Input: {url, prompt} / {query}
  Result: processed web content / search results
  Web: show as rich content with source links

9g. NotebookEdit Tool
---------------------
  Input: {notebook_path, new_source, cell_type?, edit_mode?, cell_id?}
  edit_mode: "replace" (default), "insert", "delete"
  cell_type: "code" or "markdown"
  Result: confirmation of notebook cell edit
  Web: show notebook cell editor with appropriate syntax highlighting.
  Render code cells differently from markdown cells.

9h. Task/Todo Tools (TaskCreate, TaskUpdate, TaskList, TaskGet)
---------------------------------------------------------------
  These tools manage a structured task list visible to the user.
  See §21 for full rendering details.

9i. MCP Tools (mcp__<server>__<tool>)
--------------------------------------
  MCP tools follow the naming pattern: mcp__<server>__<tool>
  Examples:
    mcp__github__search_repositories
    mcp__memory__create_entities
    mcp__filesystem__read_file

  Input/Result: varies by MCP server and tool
  Permission: MCP tools trigger permission prompts like regular tools
  Web: render tool name with server prefix for clarity.
  Show MCP server status in settings panel (see §22).


10. Signals and Process Lifecycle
=================================

10a. SIGINT (Ctrl-C)
--------------------
SIGINT kills the process immediately. No result event is emitted. The stdout
stream just ends. This is NOT a graceful shutdown.

For graceful interruption, use the control_request interrupt protocol (§2b).
The control_request sends an interrupt message on stdin, the CLI acknowledges it,
injects "[Request interrupted by user]", and emits a proper result event.

  SIGINT:             process dies → stdout EOF → no result → must detect via exit event
  control_request:    stdin message → CLI responds → result(error_during_execution) → clean

Web frontend: NEVER use SIGINT to stop a turn. Always use control_request interrupt.
Use SIGTERM only for final process cleanup (e.g., user closes the tab).

10b. Escape Key
---------------
Not applicable in stream-json mode. Escape is a terminal UI concept for canceling
the current input line. In stream-json, messages are atomic NDJSON objects — there
is no "partial input" to cancel.

Web frontend MUST handle Escape key:
  - If input field is focused with text: clear the input field (local only)
  - If a turn is running: send control_request {subtype: "interrupt"} (§2b)
    This triggers graceful cancellation with a proper result event.
  - If a permission dialog is open: send control_response with behavior: "deny"
  - NEVER send SIGINT — it kills the process with no result event (§10a)

10c. Process Exit Codes
-----------------------
  0  Normal exit (stdin closed, session complete)
  1  Error (bad JSON input, startup failure, etc.)

The process stays alive as long as stdin is open. Close stdin (EOF) to end the
session gracefully. The process exits with code 0 after emitting the final result.

If the process exits unexpectedly (non-zero exit code or signal), the web frontend
should detect this via the process exit event and show an error message.


11. Error Handling
==================

11a. API Errors
---------------
Returned as assistant text: "API Error: 400 {...}"
The result message still has subtype "success" — check the text content.

11b. Tool Errors
----------------
tool_result with is_error: true and content wrapped in <tool_use_error> tags:
  content: "<tool_use_error>File does not exist.</tool_use_error>"

11c. Turn Limit
---------------
result with subtype "error_max_turns" and empty result text.

11d. Budget Limit
-----------------
result with subtype "error_max_budget_usd"

11e. Interrupt
--------------
result with subtype "error_during_execution" after control_request interrupt.


12. Cost and Usage Tracking
===========================

The result message contains cost and usage data. IMPORTANT: these values are
CUMULATIVE across the entire session, not per-turn.

  result.total_cost_usd           Total session cost so far
  result.usage.input_tokens       Cumulative input tokens
  result.usage.output_tokens      Cumulative output tokens
  result.modelUsage               Per-model cumulative breakdown:
    {
      "claude-sonnet-4-5-20250929": {
        "inputTokens": 100,
        "outputTokens": 50,
        "cacheReadInputTokens": 15000,
        "cacheCreationInputTokens": 400,
        "costUSD": 0.042,
        "contextWindow": 200000,
        "maxOutputTokens": 64000
      }
    }

To get per-turn cost, subtract the previous turn's cumulative values.

Web frontend: show cumulative session cost in a status bar. Show per-turn cost
delta in the result notification.


13. Slash Commands — Comprehensive Reference
=============================================

The system init message lists all available slash commands under "slash_commands".
These are distinct from "skills" (also listed in init). A default session has:

  slash_commands: ["keybindings-help", "debug", "commit-message", "compact",
                   "context", "cost", "init", "pr-comments", "release-notes",
                   "review", "security-review", "insights"]
  skills: ["keybindings-help", "debug", "commit-message"]

Plugin commands (e.g., /tugtool:plan) are added when plugins are loaded.

13a. Complete Slash Command Table
----------------------------------

  Command            | Category | stream-json? | Description
  -------------------|----------|--------------|-------------------------------------------
  /compact           | Local    | Yes          | Compact conversation context. No output
                     |          |              | if successful; error if no messages yet.
  /cost              | Local    | Yes          | Session cost summary: total cost,
                     |          |              | duration, token usage, code changes.
  /context           | Local    | Yes          | Context window breakdown: tokens by
                     |          |              | category (system, tools, memory, messages,
                     |          |              | compact buffer, free space). Markdown.
  /init              | Agent    | Yes          | Reads CLAUDE.md, analyzes codebase.
                     |          |              | Full model turn with tool use.
  /review            | Agent    | Yes          | Code review. Uses gh CLI for PR context.
                     |          |              | Full model turn.
  /security-review   | Agent    | Yes          | Three-phase security audit. Full model
                     |          |              | turn with extensive tool use.
  /pr-comments       | Agent    | Yes          | Fetch and display PR comments via gh CLI.
                     |          |              | Full model turn.
  /release-notes     | Agent    | Yes          | Generate release notes from git history.
                     |          |              | Full model turn.
  /insights          | Agent    | Yes          | Codebase insights analysis. Full model
                     |          |              | turn (may take time to initialize).
  /commit-message    | Skill    | Yes          | Generate commit message from staged
                     |          |              | changes. Full model turn.
  /keybindings-help  | Skill    | Partial      | Keybinding help. Outputs to TUI; returns
                     |          |              | empty in stream-json.
  /debug             | Skill    | Partial      | Debug info/toggling. TUI-oriented.

  Categories:
    Local  — Handled entirely by the CLI. No API call. Immediate response in
             <local-command-stdout> or <local-command-stderr> tags.
    Agent  — Triggers a full model turn. Claude reads files, uses tools, and
             produces a substantive response. May take many seconds/minutes.
    Skill  — Defined as skill files. Some work in stream-json, some are TUI-only.

13b. Commands NOT in the Slash Command List
--------------------------------------------

These are TUI-only features that are NOT slash commands (not in slash_commands
array). They return "Unknown skill: <name>" if sent as messages.

  Feature    | TUI Behavior           | Web Frontend Replacement
  -----------|------------------------|------------------------------------------
  /config    | Opens settings editor  | Custom settings panel (see §19)
  /fast      | Toggles fast mode      | Model switcher via control_request
             |                        |   {subtype: "set_model"} (§2d)
  /help      | Shows help screen      | Custom help panel with local documentation

13c. Local Command Output Format
---------------------------------

Local commands (/cost, /context, /compact) return immediately without an API call:

  Success:
  {"type":"user","isReplay":true,"message":{"role":"user",
    "content":"<local-command-stdout>...output...</local-command-stdout>"}}
  {"type":"result","subtype":"success","result":""}

  Error (e.g., /compact with no messages):
  {"type":"user","isReplay":true,"message":{"role":"user",
    "content":"<local-command-stderr>Error: No messages to compact</local-command-stderr>"}}
  {"type":"result","subtype":"success","result":""}

  Note: even errors have result subtype "success" — the command executed,
  it just reported an error in its output.

13d. /context Output Detail
----------------------------

The /context command returns a markdown-formatted context usage report:

  <local-command-stdout>
  ## Context Usage
  **Model:** claude-sonnet-4-5-20250929
  **Tokens:** 23.9k / 200k (12%)

  | Category           | Tokens |
  |--------------------|--------|
  | System prompt      |  3,200 |
  | Tool definitions   |  8,400 |
  | Memory files       |    500 |
  | Skills             |  1,200 |
  | Messages           |  9,800 |
  | Compact buffer     |      0 |
  | Free space         | 176,900|
  </local-command-stdout>

  Web frontend: parse the markdown table for a visual context gauge.
  Fields available: model name, used/total tokens, percentage, per-category
  breakdown.


14. Extended Thinking
=====================

When the model uses extended thinking (e.g., with Opus or --max-thinking-tokens),
thinking content blocks appear in the assistant message:

  stream_event content_block_start:
    event.content_block.type = "thinking"

  stream_event content_block_delta:
    event.delta.type = "thinking_delta"
    event.delta.thinking = "Let me think about this..."

  assistant message content block:
    {"type": "thinking", "thinking": "full thinking text..."}

Thinking blocks appear BEFORE the text response blocks. The model may choose
not to think for simple questions even when thinking is enabled.

Web frontend: show thinking blocks in a collapsible "Thinking..." section above
the response. Stream thinking_delta events for real-time display.


15. Subagent Events (parent_tool_use_id)
========================================

When Claude uses the Task tool to spawn subagents, events from the subagent have
a non-null parent_tool_use_id field linking back to the tool_use that spawned them:

  Top-level event:     parent_tool_use_id = null
  Subagent event:      parent_tool_use_id = "toolu_xxx" (the Task tool_use ID)

This appears on system, assistant, user, result, and stream_event messages from
the subagent context. Use it to:
  - Group subagent events under their parent task in the UI
  - Show a nested/indented view of subagent activity
  - Track which subagent is producing which output

Multiple subagents can run concurrently, each with a different parent_tool_use_id.


16. Multiple Parallel Tool Uses
================================

Claude can request multiple tools in a single message. Each appears as a separate
content block in the assistant message:

  assistant.message.content = [
    {"type": "text", "text": "I'll do both..."},
    {"type": "tool_use", "id": "toolu_1", "name": "Glob", "input": {...}},
    {"type": "tool_use", "id": "toolu_2", "name": "Bash", "input": {...}}
  ]

The CLI executes them (possibly in parallel) and returns results as a single user
message with multiple tool_result blocks:

  user.message.content = [
    {"type": "tool_result", "tool_use_id": "toolu_1", "content": "...", "is_error": false},
    {"type": "tool_result", "tool_use_id": "toolu_2", "content": "...", "is_error": false}
  ]

Each tool_result has a tool_use_id linking it to the corresponding tool_use.

With streaming (--include-partial-messages), each tool_use block streams separately:
  content_block_start (index=1, tool_use) → content_block_delta (json) → assistant →
  content_block_start (index=2, tool_use) → content_block_delta (json) → assistant →
  ... then tool results arrive as a batch in a single user message.


17. Context Compaction
======================

When the conversation grows beyond the context window, the CLI automatically
compacts the context. This emits a system message:

  {"type": "system", "subtype": "compact_boundary", ...}

After compaction:
  - Earlier messages are summarized
  - A new system init is emitted
  - The conversation continues normally

Web frontend: show a visual separator ("Context compacted") in the chat history.
Optionally show a warning that earlier details may be summarized.


18. Complete Web Frontend Architecture
======================================

Process management:
  - Spawn one claude process per session
  - Keep alive across turns (multi-turn via stdin NDJSON)
  - Resume via --resume <session_id> for reconnection
  - Graceful interrupt: control_request {subtype: "interrupt"} on stdin
  - Clean shutdown: close stdin (EOF) → process exits after final result
  - Emergency shutdown: SIGTERM → wait 5s → SIGKILL

Required flags:
  --output-format stream-json
  --input-format stream-json
  --verbose
  --include-partial-messages        (for streaming text to the user)
  --permission-prompt-tool stdio    (for permission UI in the browser)

Optional flags:
  --plugin-dir <path>               (for plugins)
  --model <model>                   (user-selectable)
  --permission-mode <mode>          (user preference)
  --add-dir <paths>                 (additional directories)
  --max-turns <n>                   (safety limit)
  --max-budget-usd <n>             (cost limit)

Event loop pseudocode:
  for each NDJSON line from stdout:
    switch (msg.type):
      "system":
        if subtype === "init":
          capture session_id
          update UI with tools, model, permissionMode, slash_commands, plugins
        if subtype === "compact_boundary":
          show compaction marker in chat UI
      "stream_event":
        route on msg.event.type:
          "content_block_start":
            if content_block.type === "thinking": start thinking indicator
            if content_block.type === "text": start text block
            if content_block.type === "tool_use": start tool_use block (show name)
          "content_block_delta":
            if delta.type === "thinking_delta": append to thinking display
            if delta.type === "text_delta": append text to chat (streaming)
            if delta.type === "input_json_delta": accumulate tool JSON
          "content_block_stop": finalize block
          "message_start/stop/delta": lifecycle events (mostly ignorable for UI)
      "assistant":
        complete message — update UI with final content blocks
        (use this as the source of truth; stream_events are for real-time display)
      "user":
        if isReplay and content contains <local-command-stdout>:
          slash command output → display inline
        if isReplay and content contains <local-command-stderr>:
          slash command error → display inline with error styling
        if content contains tool_result:
          match tool_use_id to pending tool → show result
          check outer tool_use_result for structured data (§9b, §9c)
      "result":
        turn complete — update cost display, enable input
        check subtype for errors (error_max_turns, error_during_execution, etc.)
        check permission_denials array
      "control_request":
        if subtype === "can_use_tool":
          if tool_name === "AskUserQuestion":
            render question form (questions, options, multiSelect)
            collect answers → send control_response with answers map in updatedInput
          else:
            render permission dialog:
              show tool_name, input, decision_reason
              offer permission_suggestions as quick-allow options
              allow/deny → send control_response
      "control_response":
        resolve pending control_request (for interrupt, set_model, etc.)
      "control_cancel_request":
        cancel a pending permission dialog if user hasn't responded yet
      "keep_alive":
        ignore (but can use as health check signal)

User input:
  text                → send as user message (§2a)
  /command            → send as user message (slash command, §6, §13)
  image paste/drop    → send as image content block in user message (§8b)
  @file in text       → include in text, CLI handles expansion (§8a)
  stop/interrupt btn  → send control_request {subtype: "interrupt"} (§2b)
  Escape key          → context-dependent (§10b):
                         - input focused: clear input field
                         - turn running: send control_request interrupt
                         - permission dialog: send deny response
  model switcher      → send control_request {subtype: "set_model"} (§2d)
  permission mode     → send control_request {subtype: "set_permission_mode"} (§2c)
  settings panel      → custom UI, apply via control_requests (§19)

State to track:
  sessionId           from system init (§7e)
  cumulativeCost      from result.total_cost_usd (§12)
  pendingControlReqs  map of request_id → {resolve, reject} for async responses
  activeContentBlocks map of index → {type, accumulated text/json}
  toolUseMap          map of tool_use_id → {name, input, status, result}
  toolUseResultMap    map of tool_use_id → structured tool_use_result (§9b, §9c)
  taskList            array of {id, subject, status, owner, blockedBy} (§20)
  mcpServers          from system.init.mcp_servers (§21)
  currentModel        from system.init.model (updated each turn)
  permissionMode      from system.init.permissionMode (updated each turn)


19. Web UI Custom Components
=============================

These features have no stream-json protocol equivalent and require custom
web frontend implementation.

19a. Settings Panel (replaces /config)
---------------------------------------

/config is NOT a slash command — it's a TUI-only settings editor that returns
"Unknown skill: config" in stream-json mode. The web frontend must build its
own settings panel.

Available settings and how to apply them:

  Setting          | Source               | How to Change
  -----------------|----------------------|--------------------------------------------
  Model            | system.init.model    | control_request {subtype: "set_model",
                   |                      |   model: "claude-opus-4-6"} (§2d)
  Permission mode  | system.init          | control_request {subtype:
                   |   .permissionMode    |   "set_permission_mode",
                   |                      |   mode: "acceptEdits"} (§2c)
  Fast mode        | system.init          | control_request {subtype: "set_model"}
                   |   .fast_mode_state   |   to switch between models
  Output style     | system.init          | Not changeable at runtime (set at spawn)
                   |   .output_style      |

  Available models (from --help): sonnet, opus, haiku, or full model IDs like
    "claude-opus-4-6", "claude-sonnet-4-5-20250929", "claude-haiku-4-5-20251001"

  Available permission modes:
    "default"             — Ask for each action
    "acceptEdits"         — Auto-allow file edits, ask for other actions
    "bypassPermissions"   — Skip all permission checks
    "plan"                — Read-only, no file modifications allowed
    "dontAsk"             — Auto-deny permission prompts (allowed tools still work)
    "delegate"            — Coordination-only for agent teams (team management
                            tools only, no direct implementation)

  The system init is emitted at the START OF EVERY TURN, so the web frontend
  always has the current model and permissionMode values to display.

19b. Help Panel (replaces /help)
---------------------------------

/help returns "Unknown skill: help" in stream-json mode. The web frontend
must provide its own help documentation. Data sources:

  - system.init.tools: list of available tools (show tool reference)
  - system.init.slash_commands: available slash commands (show command reference)
  - system.init.skills: available skills
  - system.init.agents: available agent types
  - system.init.plugins: loaded plugins
  - system.init.claude_code_version: version info

19c. Keybindings Panel (replaces /keybindings-help)
----------------------------------------------------

/keybindings-help outputs to the TUI and returns empty in stream-json.
The web frontend should define its own keybindings and show them in a help
dialog. Recommended default bindings:

  Key              | Action
  -----------------|-------------------------------------------------
  Enter            | Submit message
  Shift+Enter      | New line in input
  Escape           | Cancel (context-dependent, see §10b)
  Ctrl+C           | Copy selected text (NOT process signal)
  Cmd/Ctrl+K       | Clear chat
  Cmd/Ctrl+/       | Toggle command palette / slash command picker
  Up arrow         | Previous message (when input is empty)

19d. Context Usage Display (enhances /context)
-----------------------------------------------

While /context works in stream-json mode (returns markdown in
<local-command-stdout>), the web frontend should provide a richer visual:

  - Context gauge: bar showing used/total tokens with percentage
  - Category breakdown: pie chart or stacked bar from /context output
  - Warning threshold: highlight when context > 80% full
  - Compaction indicator: show when compact_boundary occurs (§17)

  Data sources:
    - /context command: full token breakdown (on-demand)
    - result.usage: cumulative token counts (every turn)
    - result.modelUsage: per-model details including contextWindow (every turn)

19e. Cost Display (enhances /cost)
-----------------------------------

While /cost works in stream-json mode, the web frontend should provide
persistent cost tracking:

  - Status bar: cumulative session cost from result.total_cost_usd
  - Per-turn delta: subtract previous cumulative from current
  - Model breakdown: from result.modelUsage (§12)
  - Session duration: from result.duration_ms

19f. Diff Viewer (for Edit/Write results)
------------------------------------------

The web frontend should render Edit and Write results as visual diffs using
the structured data from tool_use_result (§9b, §9c):

  - Use structuredPatch for unified diff rendering
  - Show file path header with line numbers from oldStart/newStart
  - Color code: red for removed lines (-), green for added lines (+),
    gray for context lines ( )
  - For permission requests (control_request for Edit): show diff preview
    BEFORE the user approves, using old_string and new_string from the input
  - For Write to existing files: show full diff from structuredPatch
  - For Write to new files: show full content with "new file" indicator


20. Task/Todo System
=====================

Claude uses TaskCreate, TaskUpdate, TaskList, and TaskGet tools to manage a
structured task list. These appear as regular tool_use blocks in the protocol.

20a. TaskCreate
---------------
  tool_use input: {
    "subject": "Fix authentication bug",
    "description": "Detailed description...",
    "activeForm": "Fixing authentication bug"
  }

  - subject: imperative form title ("Run tests", "Fix bug")
  - activeForm: present continuous form for spinner ("Running tests")
  - Tasks are created with status "pending"

20b. TaskUpdate
---------------
  tool_use input: {
    "taskId": "1",
    "status": "in_progress"    // or "completed", "pending", "deleted"
  }

  Other updatable fields: subject, description, activeForm, owner,
  addBlocks (task IDs), addBlockedBy (task IDs), metadata.

20c. TaskList
-------------
  tool_use input: {} (no parameters)
  Result: summary of all tasks with id, subject, status, owner, blockedBy.

20d. TaskGet
------------
  tool_use input: {"taskId": "1"}
  Result: full task details including description and dependencies.

Web frontend rendering:
  - Show task list as a sidebar panel or floating widget
  - Display task status with visual indicators:
      pending      → gray/outline
      in_progress  → blue/spinning (show activeForm text in spinner)
      completed    → green/checkmark
  - Show dependency arrows or blocked indicators
  - Highlight the currently active task (in_progress)
  - Update in real-time as TaskUpdate tool_use blocks arrive
  - Group tasks by status or show as a kanban board

Task data comes through the standard tool_use/tool_result protocol flow.
There is no special message type for tasks.


21. MCP Tools and Servers
==========================

MCP (Model Context Protocol) servers extend Claude with external tools.

21a. MCP in System Init
------------------------
The system init message includes connected MCP servers:

  {
    "type": "system",
    "subtype": "init",
    "mcp_servers": [
      {"name": "github", "status": "connected"},
      {"name": "memory", "status": "connected"}
    ],
    ...
  }

Web frontend: show MCP server status in settings/status panel.

21b. MCP Tool Naming
---------------------
MCP tools follow a strict naming pattern:

  mcp__<server-name>__<tool-name>

Examples:
  mcp__github__search_repositories
  mcp__memory__create_entities
  mcp__filesystem__read_file
  mcp__slack__post_message

In tool_use blocks, the "name" field contains the full mcp__ prefixed name.
In permission prompts (control_request), tool_name has the same format.

Web frontend: parse the tool name to extract server and tool for display.
Show as "GitHub > Search Repositories" rather than raw "mcp__github__search_repositories".

21c. MCP Tool Permissions
--------------------------
MCP tools trigger permission prompts exactly like built-in tools (§5a).
The control_request has tool_name = "mcp__<server>__<tool>" and the full
input in the request.input field.

21d. MCP Authentication
------------------------
Some MCP servers require OAuth. The /mcp slash command handles authentication.
Send as a regular user message:
  {"type":"user","message":{"role":"user","content":[{"type":"text","text":"/mcp"}]}}

The response may trigger browser-based OAuth flows. The web frontend should
be prepared to handle or redirect to OAuth URLs returned in the response.

21e. MCP Resources
-------------------
MCP servers can expose resources referenced with @ mentions:
  @server:protocol://resource/path

Example: @github:issue://123, @docs:file://api/authentication

Web frontend: in the @ autocomplete menu, include MCP resources alongside
files. The CLI handles the actual resource fetching.


22. Hooks (Invisible Middleware)
=================================

Hooks are server-side scripts that fire at lifecycle points during a Claude
session. Hooks are TRANSPARENT to the stream-json protocol — the web frontend
does not receive hook events directly. However, hooks can modify what the web
frontend sees.

22a. How Hooks Affect the Protocol
-----------------------------------

Hooks run between the model's decision and the protocol output. They can:

  Hook Event         | Effect on Protocol
  -------------------|---------------------------------------------------
  PreToolUse         | Can deny a tool call before it executes.
                     | Web frontend sees tool_result with is_error: true.
  PermissionRequest  | Can auto-allow or auto-deny permissions.
                     | Web frontend may NEVER see the control_request.
  PostToolUse        | Can inject feedback after tool execution.
                     | Web frontend sees normal tool_result.
  UserPromptSubmit   | Can block user prompts before processing.
                     | Web frontend may see the prompt rejected.
  Stop               | Can prevent Claude from stopping.
                     | Web frontend sees the turn continue unexpectedly.
  Notification       | Fires on: permission_prompt, idle_prompt,
                     | auth_success, elicitation_dialog.
  SubagentStart/Stop | Can inject context or prevent stopping.
  SessionStart/End   | Can set up environment or clean up.
  PreCompact         | Fires before context compaction.
  TaskCompleted      | Can prevent task completion.

22b. Web Frontend Implications
-------------------------------

The web frontend should be aware of these effects:

  1. Missing permission prompts: If hooks auto-resolve permissions, the web
     frontend will see tool results without ever receiving a control_request
     for that tool. This is normal — don't treat it as an error.

  2. Unexpected continuations: Stop hooks can make Claude continue after
     what should be the final response. The web frontend should not assume
     a result event is final until it actually arrives.

  3. Blocked prompts: UserPromptSubmit hooks can reject prompts. The web
     frontend should handle the case where a submitted prompt is rejected
     (result with error).

  4. Hook errors: Hook failures may appear as system messages or affect
     tool results. The web frontend doesn't need to handle hooks directly,
     but should gracefully handle unexpected tool errors or continuations.

22c. Hook Configuration
------------------------

Hooks are configured in settings.json files (user, project, or managed scope).
The web frontend does NOT configure hooks — they are part of the CLI's
server-side configuration. However, the web frontend should:

  - Know that hooks exist (for troubleshooting unexpected behavior)
  - Not assume every tool call will trigger a permission prompt
  - Handle gracefully when expected protocol events are "missing"


23. Audit Checklist
====================

Current coverage status of all protocol features.

  Feature                  | Status              | Section    | Notes
  -------------------------|---------------------|------------|-------------------------------
  Regular messages         | Covered             | §2a        | -
  AskUserQuestion          | Covered             | §5b        | Full request/response flow
  Permission accept/deny   | Covered             | §2f, §5a   | Includes permission_suggestions
  Ctrl-C / SIGINT          | Covered             | §10a       | NEVER use; control_request only
  Escape key               | Covered             | §10b       | Context-dependent handling
  Graceful interrupt       | Covered             | §2b        | control_request interrupt
  @file references         | Covered             | §8a        | CLI handles expansion
  File/image attachments   | Covered             | §8b, §8c   | base64 content blocks
  Thinking blocks          | Covered             | §14        | thinking_delta streaming
  Cost tracking            | Covered             | §12        | Cumulative, not per-turn
  Process exit codes       | Covered             | §10c       | 0=normal, 1=error
  Subagent events          | Covered             | §15        | parent_tool_use_id
  Multiple parallel tools  | Covered             | §16        | Batch tool_result blocks
  Context compaction       | Covered             | §17        | compact_boundary system msg
  control_cancel_request   | Covered             | §3, §18    | Cancel pending permission
  Edit tool (structured)   | Covered             | §9b        | structuredPatch + originalFile
  Write tool (structured)  | Covered             | §9c        | type, content, structuredPatch
  Diff display             | Covered             | §9b, §19f  | structuredPatch rendering
  Session management       | Covered             | §7         | New, resume, fork, continue
  Session forking          | Covered             | §7d        | --fork-session for branching
  Error handling           | Covered             | §11        | API, tool, limits, interrupt
  Slash commands (all 12)  | Covered             | §13        | Local, Agent, Skill categories
  Task/Todo system         | Covered             | §20        | TaskCreate/Update/List/Get
  MCP tools & servers      | Covered             | §21        | mcp__server__tool naming
  MCP authentication       | Covered             | §21d       | /mcp command + OAuth
  MCP resources            | Covered             | §21e       | @server:protocol://path
  Hooks middleware         | Covered             | §22        | Invisible; affects permissions
  NotebookEdit tool        | Covered             | §9g        | Jupyter cell editing
  Spawn flags (complete)   | Covered             | §1         | 30+ flags documented
  All permission modes     | Covered             | §19a       | 6 modes incl dontAsk, delegate
  /config (TUI-only)       | Custom UI needed    | §19a       | Settings panel w/ control_reqs
  /fast (TUI-only)         | Custom UI needed    | §19a       | Model switcher
  /help (TUI-only)         | Custom UI needed    | §19b       | Help panel from init data
  /keybindings-help (TUI)  | Custom UI needed    | §19c       | Custom keybindings panel
  /context (enhanced)      | Custom UI optional  | §19d       | Visual gauge over raw markdown
  /cost (enhanced)         | Custom UI optional  | §19e       | Persistent status bar

  Web UI Custom Components Checklist:
  [ ] Settings panel — model, permission mode, fast mode, effort (§19a)
  [ ] Help panel — tools, commands, agents, skills, version (§19b)
  [ ] Keybindings panel — custom bindings + help dialog (§19c)
  [ ] Context gauge — visual token usage with breakdown (§19d)
  [ ] Cost display — persistent status bar with per-turn delta (§19e)
  [ ] Diff viewer — structured patch rendering for Edit/Write (§19f)
  [ ] Task list panel — task status, dependencies, active spinner (§20)
  [ ] MCP server status — connected servers, auth state (§21)
  [ ] Escape key handler — context-dependent cancellation (§10b)
  [ ] Slash command autocomplete — from system.init.slash_commands (§6)
  [ ] Permission dialog — tool_name, input, suggestions, allow/deny (§5a)
  [ ] Question form — AskUserQuestion with options + answers (§5b)
  [ ] Session management — new, resume, fork, session list (§7)
  [ ] Notebook cell viewer — code/markdown cells for NotebookEdit (§9g)
